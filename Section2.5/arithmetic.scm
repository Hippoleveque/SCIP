(define (add x y) (apply-generic 'add x y))

(define (sub x y) (apply-generic 'sub x y))

(define (mul x y) (apply-generic 'mul x y))

(define (div x y) (apply-generic 'div x y))

(define (install-scheme-number-package)
    (define (tag x) (attach-tag 'scheme-number x))

    (put 'add '(scheme-number scheme-number) (lambda (x y) (tag (+ x y))))
    (put 'sub '(scheme-number scheme-number) (lambda (x y) (tag (- x y))))
    (put 'mul '(scheme-number scheme-number) (lambda (x y) (tag (* x y))))
    (put 'div '(scheme-number scheme-number) (lambda (x y) (tag (/ x y))))
    (put 'make 'scheme-number (lambda (x) (tag x)))
    'done
)

(define (make-scheme-number x)
   ((get 'make 'scheme-number) x)
)

(define (install-rational-package)
    (define (tag x) (attach-tag 'rational x))
    (define (make a b)
        (let ((g (gcd a b)))
            (tag (cons (/ a g) (/ b g)))
        )
    )
    (define (num x) (car x))
    (define (denom x) (cdr x))
    (define (add x y)
        (make (+ (* (num x) (denom y)) (* (num y) (denom x))) (* (denom x) (denom y)))
    )
    (define (sub x y)
        (make (- (* (num x) (denom y)) (* (num y) (denom x))) (* (denom x) (denom y)))
    )
    (define (mul x y)
        (make (* (num x) (num y)) (* (denom x) (denom y)))
    )
    (define (div x y)
        (make (* (num x) (denom y)) (* (denom x) (num y)))
    )

    (put 'add '(rational rational) (lambda (x y) (tag (add x y))))
    (put 'sub '(rational rational) (lambda (x y) (tag (sub x y))))
    (put 'mul '(rational rational) (lambda (x y) (tag (mul x y))))
    (put 'div '(rational rational) (lambda (x y) (tag (div x y))))
    (put 'make 'rational (lambda (a b) (tag (make a b))))
    'done
)

(define (make-rational a b)
    (apply-generic 'make 'rational a b)
)

(define (install-complex-package)
    (define (tag x) (attach-tag 'complex x))
    (define (make-from-real-image x y)
        ((get 'make-from-real-imag 'rectangular) x y)
    )
    (define (make-from-mag-ang-polar r theta)
        ((get 'make-frommag-ang 'polar) r theta)
    )

    (define (add x y)
        (make-from-real-imag (+ (real-part x) (real-part y))
                             (+ (imag-part x) (imag-part y))
        )
    )
    (define (sub x y)
        (make-from-real-imag (- (real-part x) (real-part y))
                            (- (imag-part x) (imag-part y))
        )
    )
    (define (mul x y)
        (make-from-mag-ang-polar (* (magnitude x) (magnitude y))
                            (+ (angle x) (angle y))
        )
    )
    (define (div x y)
        (make-from-mag-ang-polar (/ (magnitude x) (magnitude y))
                            (- (angle x) (angle y))
        )
    )

    (put 'make-from-real-imag 'complex (lambda (x y) (tag (make-from-real-imag x y))))
    (put 'make-from-mag-ang-polar 'complex (lambda (r theta) (tag (make-from-mag-ang-polar r theta))))
    (put 'add '(complex complex) (lambda (x y) (tag (add x y))))
    (put 'sub '(complex complex) (lambda (x y) (tag (sub x y))))
    (put 'mul '(complex complex) (lambda (x y) (tag (mul x y))))
    (put 'div '(complex complex) (lambda (x y) (tag (div x y))))
    (put 'real-part '(complex) real-part)
    (put 'imag-part '(complex) imag-part)
    (put 'magnitude '(complex) magnitude)
    (put 'angle '(complex) angle)
    'done
)

(define (make-from-mag-ang r theta)
    ((get 'make-from-mag-ang 'complex) r theta)
)

(define (make-from-real-imag x y)
    ((get 'make-from-real-image 'complex) x y)
)

#| My implementation |#

(define (apply-generic op . args)
    (let ((type-tags (mapper type-tag args)))
         (let ((proc (get op type-tags)))
            (if proc 
                (apply proc (mapper contents args))
                (let ((coercion-first->second (apply get-coercion type-tags)))
                    (if coercion-first->second
                        (let ((proc-second) (get op (list (cadr (type-tags)) (cadr (type-tags)))))
                            (if proc-second
                                (apply proc-second (list (coercion-first->second (contents (car args))) (contents (cadr args))))
                                (else (error "operation not supported for types" (cadr type-tags)))
                            )
                        )
                        (let ((coercion-second->first (apply get-coercion (list (cadr (type-tags)) (car (type-tags))))))
                            (if coercion-second->first
                                    (let ((proc-first) (get op (list (car type-tags) (car type-tags))))
                                        (if proc-first
                                            (apply proc-first (list (contents (car args)) (coercion-second->first (contents (cadr args)))))
                                            (else (error "operation not supported for types" (car type-tags))
                                        )
                                
                                    ))
                            )
                        )
                    )
            
                )
            )
         )

    )
)

#| Book implementation |#

(define (apply-generic op . args)
    (let ((type-tags (mapper type-tag args)))
        (let ((proc (get op type-tags)))
            (if proc
                (apply proc (mapper contents args))
                (if (= 2 (length args))
                    (let ((a1 (car args))
                          (a2 (cadr args))
                          (t1 (car type-tags))
                          (t2 (cadr type-tags))
                        )
                        (let ((t1->t2 (get-coercion t1 t2))
                              (t2->t1 (get coercion t2 t1))
                            )
                            (cond ((t1->t2) (apply-generic op (t1->t2 a1) a2))
                                  ((t2->t1) (apply-generic op a1 (t2->t1 a2)))
                                  (else (error "No methods for theses types" (list op type-tags)))
                        
                            )
                        )    
                    )
                    (error "No method for these types" (list op type-tags))
                )
            )
        )
    )
)

(define (add-poly p1 p2)
    (if (same-variable? (variable p1) (variable p2))
        (make-poly (variable p1) 
                   (add-terms (term-list p1) 
                              (term-list p2)
                   )
        )
        (error "Can't add polys with different variables")

    )
)

(define (mul-poly p1 p2)
    (if (same-variable? (variable p1) (variable p2))
        (make-poly (varibale p1) 
                   (mul-terms (term-list p1)
                              (term-list p2)
                    )
        )
    )
)

(define (install-poly-pakage)

    (define (make-poly variable term-list)
        (cons varibale term-list)
    )

    (define (variable p)
        (car p)
    )

    (define (term-list p)
        (cdr p)
    )

    (define (variable? e)
        (symbol? e)
    )

    (define (same-variable? v1 v2)
        (and (variable? v1) (variable? v2) (eq? v1 v2))
    )

    (define (add-poly p1 p2)
        (if (same-variable? (variable p1) (variable p2))
            (make-poly (variable p1) 
                    (add-terms (term-list p1) 
                               (term-list p2)
                    )
            )
            (error "Can't add polys with different variables")
        )
    )

    (define (mul-poly p1 p2)
        (if (same-variable? (variable p1) (variable p2))
            (make-poly (varibale p1) 
                    (mul-terms (term-list p1)
                               (term-list p2)
                    )
            )
        )
    )

    (define (tag p)
        (attach-tag 'polynomial p)
    )
    (put 'add '(polynomial polynomial) (lambda (x y) (tag (add-poly x y))))
    (put 'mul '(polynomial polynomial) (lambda (x y) (tag (mul-poly x y))))
    (put 'make 'polynomial (lambda (variable term-list) (tag (make-poly variable term-list))))

)

(define (add-terms L1 L2)
    (cond ((empty-termlist? L1) L2)
          ((empty-termlist? L2) L1)
          (else 
            (let ((t1 (first-term L1))
                  (t2 (first-term L2)))
                 (let ((c1 (coeff L1))
                       (c2 (coeff L2))
                       (o1 (order L1))
                       (o2 (order L2))
                       )
                
                 )
                 (cond ((> o1 o2) (adjoin-term t1 (add-terms (rest-terms) L2)))
                       ((< o1 o2) (adjoin-term t2 (add-terms L1 (rest-terms L2))))
                       ((= o1 o2) (adjoin-term (make-term o1 (+ c1 c2))) (add-terms (rest-terms L1) (rest-terms L2)))
                )
            )
        )
    )
)

(define (mul-terms L1 L2)
    (if (empty-termlist? L1)
        (the-empty-termlist)
        (add-terms (mul-term-by-all-terms (first-term L1) L2) (mul-terms (rest-terms L1) L2))
    )
)

(define (mul-term-by-all-terms t L)
    (if (empty-termlist? L)
        (the-empty-termlist)
        (adjoin-term (make-term (+ (order t) (order (first-term L)))
                                (* (coeff t) (coeff (first-term L))))
                     (mul-term-by-all-terms t (rest-terms L))
        )
    )
)

(define (adjoin-term term term-list)
        (if (zero? (coeff term))
            term-list
            (cons term term-list)
        )
)

(define (the-empty-termlist) '())
(define (first-term L) (car L))
(define (rest-terms L) (cdr L))
(define (empty-termlist? L) (null? L))

(define (make-term order coeff)
    (list order coeff)
)
(define (order t) (car t))
(define (coeff t) (cadr t))

(define (make-polynomial var terms)
    ((get 'make 'polynomial) var terms)
)